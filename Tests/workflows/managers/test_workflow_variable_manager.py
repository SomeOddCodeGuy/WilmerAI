# tests/workflows/managers/test_workflow_variable_manager.py

from unittest.mock import MagicMock, patch

import pytest

from Middleware.workflows.managers.workflow_variable_manager import WorkflowVariableManager
from Middleware.workflows.models.execution_context import ExecutionContext


@pytest.fixture
def mock_llm_handler() -> MagicMock:
    """Provides a mock LLM handler for testing."""
    handler = MagicMock()
    handler.prompt_template_file_name = "test_template.json"
    handler.takes_message_collection = True
    return handler


# --- MODIFIED FIXTURE ---
# The fixture is updated to provide agent_inputs as a dictionary,
# which is the format that revealed the original bug.
@pytest.fixture
def mock_context(mock_llm_handler) -> MagicMock:
    """Provides a mock ExecutionContext with dictionary-based agent_inputs."""
    context = MagicMock(spec=ExecutionContext)
    context.config = {"jinja2": False}
    context.workflow_config = {"custom_var": "custom_value", "nodes": []}
    context.discussion_id = "test_discussion_123"
    context.messages = [{"role": "user", "content": "Hello"}]
    context.llm_handler = mock_llm_handler
    context.agent_outputs = {"agent1Output": "Output from node 1"}
    # This is the key change: agent_inputs is now a dictionary.
    context.agent_inputs = {
        "agent1Input": "Input from parent workflow",
        "agent2Input": "Second input from parent"
    }
    return context


@patch('Middleware.workflows.managers.workflow_variable_manager.TimestampService')
@patch('Middleware.workflows.managers.workflow_variable_manager.MemoryService')
def test_init_and_set_categories(MockMemoryService, MockTimestampService):
    """
    Tests that the constructor correctly initializes services and sets category attributes from kwargs.
    """
    # Arrange: Define kwargs with category information
    kwargs = {
        "category_list": ["cat1", "cat2"],
        "category_descriptions": "desc1, desc2",
        "some_other_kwarg": "ignore_me"  # Should be ignored
    }

    # Act: Initialize the manager
    manager = WorkflowVariableManager(**kwargs)

    # Assert: Check that services were instantiated and attributes were set
    MockMemoryService.assert_called_once()
    MockTimestampService.assert_called_once()
    assert manager.category_list == ["cat1", "cat2"]
    assert manager.category_descriptions == "desc1, desc2"
    assert not hasattr(manager, "some_other_kwarg")
    assert manager.categoriesSeparatedByOr is None  # Should be None if not provided

    # Test initialization without any category kwargs
    manager_no_kwargs = WorkflowVariableManager()
    assert manager_no_kwargs.category_list is None


def test_extract_additional_attributes():
    """
    Tests that only predefined, non-None category attributes are extracted.
    """
    # Arrange: Initialize with some category attributes set
    kwargs = {
        "category_list": ["cat1"],
        "categoryNameBulletpoints": "- cat1",
        "category_descriptions": None  # Should be ignored
    }
    manager = WorkflowVariableManager(**kwargs)

    # Act: Extract the attributes
    attributes = manager.extract_additional_attributes()

    # Assert: Verify the correct dictionary is returned
    expected_attributes = {
        "category_list": ["cat1"],
        "categoryNameBulletpoints": "- cat1"
    }
    assert attributes == expected_attributes

    # Arrange: Test with no attributes set
    manager_empty = WorkflowVariableManager()
    # Act
    empty_attributes = manager_empty.extract_additional_attributes()
    # Assert
    assert empty_attributes == {}


def test_generate_conversation_turn_variables(mocker):
    """
    Tests that conversation turn variables are generated by calling the correct utility functions.
    """
    # Arrange: Mock the external utility functions
    mock_extract_str = mocker.patch(
        'Middleware.workflows.managers.workflow_variable_manager.extract_last_n_turns_as_string',
        side_effect=lambda messages, n, *args: f"raw_string_n{n}")
    mock_get_formatted_str = mocker.patch(
        'Middleware.workflows.managers.workflow_variable_manager.get_formatted_last_n_turns_as_string',
        side_effect=lambda messages, n, *args, **kwargs: f"templated_string_n{n}")

    mock_handler = MagicMock()
    mock_handler.prompt_template_file_name = "test.json"
    mock_handler.takes_message_collection = True  # This sets include_sysmes to True

    messages = [{"role": "user", "content": "Test"}]

    # Act
    result = WorkflowVariableManager.generate_conversation_turn_variables(
        originalMessages=messages,
        llm_handler=mock_handler,
        remove_all_system_override=False
    )

    # Assert: Check that all keys are present and have the mocked values
    assert result["chat_user_prompt_last_one"] == "raw_string_n1"
    assert result["templated_user_prompt_last_one"] == "templated_string_n1"
    assert result["chat_user_prompt_last_twenty"] == "raw_string_n20"
    assert result["templated_user_prompt_last_twenty"] == "templated_string_n20"

    # Assert that the mocks were called with the correct parameters for a sample case
    mock_extract_str.assert_any_call(messages, 1, True, False)
    mock_get_formatted_str.assert_any_call(
        messages, 1,
        template_file_name="test.json",
        isChatCompletion=True
    )


def test_process_conversation_turn_variables(mocker, mock_llm_handler):
    """
    Tests that conversation strings are correctly templated based on the key and llm_handler presence.
    """
    # Arrange: Mock the dependency functions
    mocker.patch(
        'Middleware.workflows.managers.workflow_variable_manager.get_chat_template_name',
        return_value="chat_template.json")
    mock_format_prompt = mocker.patch(
        'Middleware.workflows.managers.workflow_variable_manager.format_templated_prompt',
        side_effect=lambda text, handler, template: f"formatted_{text}_with_{template}")

    prompts = {
        "chat_user_prompt_last_one": "hello",
        "templated_user_prompt_last_one": "world"
    }

    # Act 1: Test with a full llm_handler
    result = WorkflowVariableManager.process_conversation_turn_variables(prompts, mock_llm_handler)

    # Assert 1: Check logic for selecting templates
    assert result["chat_user_prompt_last_one"] == "formatted_hello_with_chat_template.json"
    assert result["templated_user_prompt_last_one"] == "formatted_world_with_test_template.json"

    # Act 2: Test with no llm_handler (should default to chat template)
    mock_format_prompt.reset_mock()
    result_no_handler = WorkflowVariableManager.process_conversation_turn_variables(prompts, None)

    # Assert 2
    assert result_no_handler["templated_user_prompt_last_one"] == "formatted_world_with_chat_template.json"
    mock_format_prompt.assert_any_call("world", None, "chat_template.json")


def test_generate_chat_summary_variables(mocker):
    """
    Tests that chat summary variables are correctly retrieved from the MemoryService.
    """
    # Arrange: Mock the MemoryService methods
    mock_memory_service = MagicMock()
    mock_memory_service.get_chat_summary_memories.return_value = "new_memories_for_summary"
    mock_memory_service.get_current_summary.return_value = "the_current_summary"

    manager = WorkflowVariableManager()
    manager.memory_service = mock_memory_service

    messages = [{"role": "user", "content": "test"}]
    discussion_id = "disc_123"

    # Act
    result = manager.generate_chat_summary_variables(messages, discussion_id)

    # Assert
    assert result["newest_chat_summary_memories"] == "new_memories_for_summary"
    assert result["current_chat_summary"] == "the_current_summary"
    mock_memory_service.get_chat_summary_memories.assert_called_once_with(messages, discussion_id)
    mock_memory_service.get_current_summary.assert_called_once_with(discussion_id)


# This test specifically validates that agent_inputs provided as a dictionary
# are correctly processed and added to the final variables map. This test
# would have failed with the buggy code.
def test_generate_variables_handles_agent_inputs_dictionary(mock_context, mocker):
    """
    Tests that agent_inputs provided as a dictionary are correctly added to the variables.
    This is the regression test for the bug where dictionary iteration was incorrect.
    """
    # Arrange
    manager = WorkflowVariableManager()

    # Mock the internal dependency that was trying to access the file system.
    # This keeps the test isolated to only the logic within generate_variables.
    mocker.patch.object(
        manager,
        'generate_conversation_turn_variables',
        return_value={"mock_convo_var": "mock_value"}
    )

    # We also need to mock this utility function called inside generate_variables
    mocker.patch(
        'Middleware.workflows.managers.workflow_variable_manager.format_system_prompts',
        return_value={}
    )

    # Act
    variables = manager.generate_variables(mock_context)

    # Assert
    # Check that the dictionary from the fixture was correctly unpacked.
    assert 'agent1Input' in variables
    assert variables['agent1Input'] == "Input from parent workflow"
    assert 'agent2Input' in variables
    assert variables['agent2Input'] == "Second input from parent"

    # Also ensure that agent_outputs were not lost in the process
    assert 'agent1Output' in variables
    assert variables['agent1Output'] == "Output from node 1"


# --- REFACTORED AND CLEANED UP TEST ---
# The original test was convoluted. This version is cleaner and acts as a
# good integration test for the entire generate_variables method, now using
# the updated fixture with dictionary-based agent_inputs.
def test_generate_variables_integration(mocker, mock_context):
    """
    Tests the main variable aggregation logic, ensuring all sources are combined correctly.
    """
    # Arrange: Mock all external dependencies of the generate_variables method
    mocker.patch('Middleware.workflows.managers.workflow_variable_manager.datetime')
    manager = WorkflowVariableManager()

    mock_ts_service = MagicMock()
    mock_ts_service.get_time_context_summary.return_value = "time_summary"
    manager.timestamp_service = mock_ts_service

    mocker.patch.object(manager, 'generate_conversation_turn_variables',
                        return_value={"chat_user_prompt_last_one": "hello"})
    mocker.patch.object(manager, 'extract_additional_attributes', return_value={"category_list": ["test"]})
    mocker.patch('Middleware.workflows.managers.workflow_variable_manager.format_system_prompts',
                 return_value={"templated_system_prompt": "system prompt"})

    # Act
    variables = manager.generate_variables(mock_context)

    # Assert: Verify variables from each source are present and correct
    assert 'todays_date_pretty' in variables
    assert variables['custom_var'] == 'custom_value'
    assert 'nodes' not in variables
    assert variables['time_context_summary'] == "time_summary"
    assert variables['chat_user_prompt_last_one'] == "hello"
    assert variables['templated_system_prompt'] == "system prompt"
    assert variables['agent1Output'] == "Output from node 1"
    assert variables['agent1Input'] == "Input from parent workflow"  # Now correctly asserts the dict value
    assert variables['agent2Input'] == "Second input from parent"
    assert variables['category_list'] == ["test"]

    # Assert mocks were called correctly
    mock_ts_service.get_time_context_summary.assert_called_once_with("test_discussion_123")


def test_apply_variables_standard_format(mocker, mock_context):
    """
    Tests variable substitution using standard Python string.format().
    """
    # Arrange
    manager = WorkflowVariableManager()
    mocker.patch.object(manager, 'generate_variables', return_value={"name": "Wilmer", "action": "testing"})
    prompt = "My name is {name} and I am {action}."
    mock_context.config = {'jinja2': False}

    # Act
    result = manager.apply_variables(prompt, mock_context)

    # Assert
    assert result == "My name is Wilmer and I am testing."
    manager.generate_variables.assert_called_once_with(mock_context, None)


def test_apply_variables_jinja2_format(mocker, mock_context):
    """
    Tests variable substitution using the Jinja2 templating engine.
    """
    # Arrange
    manager = WorkflowVariableManager()
    mocker.patch.object(manager, 'generate_variables', return_value={"user_name": "Tester"})
    mock_context.config = {'jinja2': True}
    mock_context.messages = [{'role': 'user', 'content': 'Hi'}]
    prompt = "Summary for {{ user_name }}:\n{% for msg in messages %}- {{ msg.role }}\n{% endfor %}"
    expected_output = "Summary for Tester:\n- user\n"

    # Act
    result = manager.apply_variables(prompt, mock_context)

    # Assert
    assert result == expected_output


# --- NEW JINJA2 TESTS ---

def test_apply_variables_jinja2_with_agent_io_and_conditional(mocker, mock_context):
    """
    Tests Jinja2 rendering with a complex template involving agent inputs,
    agent outputs, and conditional logic, reflecting a real-world use case.
    """
    # Arrange
    manager = WorkflowVariableManager()

    # Setup the variables that would be returned by generate_variables
    test_variables = {
        "agent1Output": "SUCCESS",
        "agent2Input": "Initial Data From Parent",
        "agent3Output": "NO_TITLE_FOUND"  # for testing the 'else' branch
    }
    mocker.patch.object(manager, 'generate_variables', return_value=test_variables)
    mock_context.config = {'jinja2': True}

    # Act & Assert - Test the 'if' branch
    prompt_if = "{% if agent1Output == 'SUCCESS' %}Data: {{ agent2Input }}{% else %}Error{% endif %}"
    result_if = manager.apply_variables(prompt_if, mock_context)
    assert result_if == "Data: Initial Data From Parent"

    # Act & Assert - Test the 'else' branch
    prompt_else = "{% if agent3Output != 'NO_TITLE_FOUND' %}Title: {{ agent3Output }}{% else %}No Title Provided{% endif %}"
    result_else = manager.apply_variables(prompt_else, mock_context)
    assert result_else == "No Title Provided"


def test_apply_variables_key_error_fallback(mocker, mock_context):
    """
    Tests that standard formatting gracefully fails and logs a warning on a KeyError.
    """
    # Arrange
    mock_log_warning = mocker.patch('Middleware.workflows.managers.workflow_variable_manager.logger.warning')
    manager = WorkflowVariableManager()
    mocker.patch.object(manager, 'generate_variables', return_value={"name": "Wilmer"})
    mock_context.config = {'jinja2': False}
    prompt = "Hello {name}, this is an {undefined_key}."

    # Act
    result = manager.apply_variables(prompt, mock_context)

    # Assert: Should return the original prompt and log a warning
    assert result == prompt
    mock_log_warning.assert_called_once()
    assert "A key error occurred" in mock_log_warning.call_args[0][0]
