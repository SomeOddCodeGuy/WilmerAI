# tests/workflows/managers/test_workflow_variable_manager.py

from unittest.mock import MagicMock, patch

import pytest

from Middleware.workflows.managers.workflow_variable_manager import WorkflowVariableManager
from Middleware.workflows.models.execution_context import ExecutionContext


@pytest.fixture
def mock_llm_handler() -> MagicMock:
    """Provides a mock LLM handler for testing."""
    handler = MagicMock()
    handler.prompt_template_file_name = "test_template.json"
    handler.takes_message_collection = True
    return handler


# --- MODIFIED FIXTURE ---
# The fixture is updated to provide agent_inputs as a dictionary,
# which is the format that revealed the original bug.
@pytest.fixture
def mock_context(mock_llm_handler) -> MagicMock:
    """Provides a mock ExecutionContext with dictionary-based agent_inputs."""
    context = MagicMock(spec=ExecutionContext)
    context.config = {"jinja2": False}
    context.workflow_config = {"custom_var": "custom_value", "nodes": []}
    context.discussion_id = "test_discussion_123"
    context.messages = [{"role": "user", "content": "Hello"}]
    context.llm_handler = mock_llm_handler
    context.agent_outputs = {"agent1Output": "Output from node 1"}
    # This is the key change: agent_inputs is now a dictionary.
    context.agent_inputs = {
        "agent1Input": "Input from parent workflow",
        "agent2Input": "Second input from parent"
    }
    return context


@patch('Middleware.workflows.managers.workflow_variable_manager.TimestampService')
@patch('Middleware.workflows.managers.workflow_variable_manager.MemoryService')
def test_init_and_set_categories(MockMemoryService, MockTimestampService):
    """
    Tests that the constructor correctly initializes services and sets category attributes from kwargs.
    """
    # Arrange: Define kwargs with category information
    kwargs = {
        "category_list": ["cat1", "cat2"],
        "category_descriptions": "desc1, desc2",
        "some_other_kwarg": "ignore_me"  # Should be ignored
    }

    # Act: Initialize the manager
    manager = WorkflowVariableManager(**kwargs)

    # Assert: Check that services were instantiated and attributes were set
    MockMemoryService.assert_called_once()
    MockTimestampService.assert_called_once()
    assert manager.category_list == ["cat1", "cat2"]
    assert manager.category_descriptions == "desc1, desc2"
    assert not hasattr(manager, "some_other_kwarg")
    assert manager.categoriesSeparatedByOr is None  # Should be None if not provided

    # Test initialization without any category kwargs
    manager_no_kwargs = WorkflowVariableManager()
    assert manager_no_kwargs.category_list is None


def test_extract_additional_attributes():
    """
    Tests that only predefined, non-None category attributes are extracted.
    """
    # Arrange: Initialize with some category attributes set
    kwargs = {
        "category_list": ["cat1"],
        "categoryNameBulletpoints": "- cat1",
        "category_descriptions": None  # Should be ignored
    }
    manager = WorkflowVariableManager(**kwargs)

    # Act: Extract the attributes
    attributes = manager.extract_additional_attributes()

    # Assert: Verify the correct dictionary is returned
    expected_attributes = {
        "category_list": ["cat1"],
        "categoryNameBulletpoints": "- cat1"
    }
    assert attributes == expected_attributes

    # Arrange: Test with no attributes set
    manager_empty = WorkflowVariableManager()
    # Act
    empty_attributes = manager_empty.extract_additional_attributes()
    # Assert
    assert empty_attributes == {}


def test_generate_conversation_turn_variables(mocker):
    """
    Tests that conversation turn variables are generated by calling the correct utility functions.
    """
    # Arrange: Mock the external utility functions
    mock_extract_str = mocker.patch(
        'Middleware.workflows.managers.workflow_variable_manager.extract_last_n_turns_as_string',
        side_effect=lambda messages, n, *args: f"raw_string_n{n}")
    mock_get_formatted_str = mocker.patch(
        'Middleware.workflows.managers.workflow_variable_manager.get_formatted_last_n_turns_as_string',
        side_effect=lambda messages, n, *args, **kwargs: f"templated_string_n{n}")

    mock_handler = MagicMock()
    mock_handler.prompt_template_file_name = "test.json"
    mock_handler.takes_message_collection = True  # This sets include_sysmes to True

    messages = [{"role": "user", "content": "Test"}]

    # Act
    result = WorkflowVariableManager.generate_conversation_turn_variables(
        originalMessages=messages,
        llm_handler=mock_handler,
        remove_all_system_override=False
    )

    # Assert: Check that all keys are present and have the mocked values
    assert result["chat_user_prompt_last_one"] == "raw_string_n1"
    assert result["templated_user_prompt_last_one"] == "templated_string_n1"
    assert result["chat_user_prompt_last_twenty"] == "raw_string_n20"
    assert result["templated_user_prompt_last_twenty"] == "templated_string_n20"

    # Assert that the mocks were called with the correct parameters for a sample case
    mock_extract_str.assert_any_call(messages, 1, True, False)
    mock_get_formatted_str.assert_any_call(
        messages, 1,
        template_file_name="test.json",
        isChatCompletion=True
    )


def test_process_conversation_turn_variables(mocker, mock_llm_handler):
    """
    Tests that conversation strings are correctly templated based on the key and llm_handler presence.
    """
    # Arrange: Mock the dependency functions
    mocker.patch(
        'Middleware.workflows.managers.workflow_variable_manager.get_chat_template_name',
        return_value="chat_template.json")
    mock_format_prompt = mocker.patch(
        'Middleware.workflows.managers.workflow_variable_manager.format_templated_prompt',
        side_effect=lambda text, handler, template: f"formatted_{text}_with_{template}")

    prompts = {
        "chat_user_prompt_last_one": "hello",
        "templated_user_prompt_last_one": "world"
    }

    # Act 1: Test with a full llm_handler
    result = WorkflowVariableManager.process_conversation_turn_variables(prompts, mock_llm_handler)

    # Assert 1: Check logic for selecting templates
    assert result["chat_user_prompt_last_one"] == "formatted_hello_with_chat_template.json"
    assert result["templated_user_prompt_last_one"] == "formatted_world_with_test_template.json"

    # Act 2: Test with no llm_handler (should default to chat template)
    mock_format_prompt.reset_mock()
    result_no_handler = WorkflowVariableManager.process_conversation_turn_variables(prompts, None)

    # Assert 2
    assert result_no_handler["templated_user_prompt_last_one"] == "formatted_world_with_chat_template.json"
    mock_format_prompt.assert_any_call("world", None, "chat_template.json")


def test_generate_chat_summary_variables(mocker):
    """
    Tests that chat summary variables are correctly retrieved from the MemoryService.
    """
    # Arrange: Mock the MemoryService methods
    mock_memory_service = MagicMock()
    mock_memory_service.get_chat_summary_memories.return_value = "new_memories_for_summary"
    mock_memory_service.get_current_summary.return_value = "the_current_summary"

    manager = WorkflowVariableManager()
    manager.memory_service = mock_memory_service

    messages = [{"role": "user", "content": "test"}]
    discussion_id = "disc_123"

    # Act
    result = manager.generate_chat_summary_variables(messages, discussion_id)

    # Assert
    assert result["newest_chat_summary_memories"] == "new_memories_for_summary"
    assert result["current_chat_summary"] == "the_current_summary"
    mock_memory_service.get_chat_summary_memories.assert_called_once_with(messages, discussion_id)
    mock_memory_service.get_current_summary.assert_called_once_with(discussion_id)


# This test specifically validates that agent_inputs provided as a dictionary
# are correctly processed and added to the final variables map. This test
# would have failed with the buggy code.
def test_generate_variables_handles_agent_inputs_dictionary(mock_context, mocker):
    """
    Tests that agent_inputs provided as a dictionary are correctly added to the variables.
    This is the regression test for the bug where dictionary iteration was incorrect.
    """
    # Arrange
    manager = WorkflowVariableManager()

    # Mock the internal dependency that was trying to access the file system.
    # This keeps the test isolated to only the logic within generate_variables.
    mocker.patch.object(
        manager,
        'generate_conversation_turn_variables',
        return_value={"mock_convo_var": "mock_value"}
    )

    # We also need to mock this utility function called inside generate_variables
    mocker.patch(
        'Middleware.workflows.managers.workflow_variable_manager.format_system_prompts',
        return_value={}
    )

    # Act
    variables = manager.generate_variables(mock_context)

    # Assert
    # Check that the dictionary from the fixture was correctly unpacked.
    assert 'agent1Input' in variables
    assert variables['agent1Input'] == "Input from parent workflow"
    assert 'agent2Input' in variables
    assert variables['agent2Input'] == "Second input from parent"

    # Also ensure that agent_outputs were not lost in the process
    assert 'agent1Output' in variables
    assert variables['agent1Output'] == "Output from node 1"


# --- REFACTORED AND CLEANED UP TEST ---
# The original test was convoluted. This version is cleaner and acts as a
# good integration test for the entire generate_variables method, now using
# the updated fixture with dictionary-based agent_inputs.
def test_generate_variables_integration(mocker, mock_context):
    """
    Tests the main variable aggregation logic, ensuring all sources are combined correctly.
    """
    # Arrange: Mock all external dependencies of the generate_variables method
    mocker.patch('Middleware.workflows.managers.workflow_variable_manager.datetime')
    manager = WorkflowVariableManager()

    mock_ts_service = MagicMock()
    mock_ts_service.get_time_context_summary.return_value = "time_summary"
    manager.timestamp_service = mock_ts_service

    mocker.patch.object(manager, 'generate_conversation_turn_variables',
                        return_value={"chat_user_prompt_last_one": "hello"})
    mocker.patch.object(manager, 'extract_additional_attributes', return_value={"category_list": ["test"]})
    mocker.patch('Middleware.workflows.managers.workflow_variable_manager.format_system_prompts',
                 return_value={"templated_system_prompt": "system prompt"})

    # Act
    variables = manager.generate_variables(mock_context)

    # Assert: Verify variables from each source are present and correct
    assert 'todays_date_pretty' in variables
    assert variables['custom_var'] == 'custom_value'
    assert 'nodes' not in variables
    assert variables['time_context_summary'] == "time_summary"
    assert variables['chat_user_prompt_last_one'] == "hello"
    assert variables['templated_system_prompt'] == "system prompt"
    assert variables['agent1Output'] == "Output from node 1"
    assert variables['agent1Input'] == "Input from parent workflow"  # Now correctly asserts the dict value
    assert variables['agent2Input'] == "Second input from parent"
    assert variables['category_list'] == ["test"]

    # Assert mocks were called correctly
    mock_ts_service.get_time_context_summary.assert_called_once_with("test_discussion_123")


def test_apply_variables_standard_format(mocker, mock_context):
    """
    Tests variable substitution using standard Python string.format().
    """
    # Arrange
    manager = WorkflowVariableManager()
    mocker.patch.object(manager, 'generate_variables', return_value={"name": "Wilmer", "action": "testing"})
    prompt = "My name is {name} and I am {action}."
    mock_context.config = {'jinja2': False}

    # Act
    result = manager.apply_variables(prompt, mock_context)

    # Assert
    assert result == "My name is Wilmer and I am testing."
    manager.generate_variables.assert_called_once_with(mock_context, None)


def test_apply_variables_jinja2_format(mocker, mock_context):
    """
    Tests variable substitution using the Jinja2 templating engine.
    """
    # Arrange
    manager = WorkflowVariableManager()
    mocker.patch.object(manager, 'generate_variables', return_value={"user_name": "Tester"})
    mock_context.config = {'jinja2': True}
    mock_context.messages = [{'role': 'user', 'content': 'Hi'}]
    prompt = "Summary for {{ user_name }}:\n{% for msg in messages %}- {{ msg.role }}\n{% endfor %}"
    expected_output = "Summary for Tester:\n- user\n"

    # Act
    result = manager.apply_variables(prompt, mock_context)

    # Assert
    assert result == expected_output


# --- NEW JINJA2 TESTS ---

def test_apply_variables_jinja2_with_agent_io_and_conditional(mocker, mock_context):
    """
    Tests Jinja2 rendering with a complex template involving agent inputs,
    agent outputs, and conditional logic, reflecting a real-world use case.
    """
    # Arrange
    manager = WorkflowVariableManager()

    # Setup the variables that would be returned by generate_variables
    test_variables = {
        "agent1Output": "SUCCESS",
        "agent2Input": "Initial Data From Parent",
        "agent3Output": "NO_TITLE_FOUND"  # for testing the 'else' branch
    }
    mocker.patch.object(manager, 'generate_variables', return_value=test_variables)
    mock_context.config = {'jinja2': True}

    # Act & Assert - Test the 'if' branch
    prompt_if = "{% if agent1Output == 'SUCCESS' %}Data: {{ agent2Input }}{% else %}Error{% endif %}"
    result_if = manager.apply_variables(prompt_if, mock_context)
    assert result_if == "Data: Initial Data From Parent"

    # Act & Assert - Test the 'else' branch
    prompt_else = "{% if agent3Output != 'NO_TITLE_FOUND' %}Title: {{ agent3Output }}{% else %}No Title Provided{% endif %}"
    result_else = manager.apply_variables(prompt_else, mock_context)
    assert result_else == "No Title Provided"


def test_apply_variables_key_error_fallback(mocker, mock_context):
    """
    Tests that standard formatting gracefully fails and logs a warning on a KeyError.
    """
    # Arrange
    mock_log_warning = mocker.patch('Middleware.workflows.managers.workflow_variable_manager.logger.warning')
    manager = WorkflowVariableManager()
    mocker.patch.object(manager, 'generate_variables', return_value={"name": "Wilmer"})
    mock_context.config = {'jinja2': False}
    prompt = "Hello {name}, this is an {undefined_key}."

    # Act
    result = manager.apply_variables(prompt, mock_context)

    # Assert: Should return the original prompt and log a warning
    assert result == prompt
    mock_log_warning.assert_called_once()
    assert "A key error occurred" in mock_log_warning.call_args[0][0]


# --- NEW TESTS FOR apply_early_variables METHOD ---
# These tests verify the functionality we added to support early variable
# substitution for endpointName and preset fields

class TestApplyEarlyVariables:
    """Tests for the apply_early_variables method that handles early substitution without llm_handler."""

    def test_apply_early_variables_with_agent_inputs(self):
        """Tests that agent input variables are correctly substituted."""
        # Arrange
        manager = WorkflowVariableManager()
        agent_inputs = {
            "agent1Input": "MyEndpoint",
            "agent2Input": "MyPreset"
        }
        prompt = "{agent1Input}/{agent2Input}"

        # Act
        result = manager.apply_early_variables(prompt, agent_inputs=agent_inputs)

        # Assert
        assert result == "MyEndpoint/MyPreset"

    def test_apply_early_variables_with_workflow_config(self):
        """Tests that workflow config variables are correctly substituted."""
        # Arrange
        manager = WorkflowVariableManager()
        workflow_config = {
            "endpoint": "TestEndpoint",
            "preset": "TestPreset",
            "nodes": ["should_be_ignored"]  # nodes should be excluded
        }
        prompt = "{endpoint}_with_{preset}"

        # Act
        result = manager.apply_early_variables(prompt, workflow_config=workflow_config)

        # Assert
        assert result == "TestEndpoint_with_TestPreset"

    def test_apply_early_variables_with_both_sources(self):
        """Tests that both agent inputs and workflow config variables work together."""
        # Arrange
        manager = WorkflowVariableManager()
        agent_inputs = {"agent1Input": "Dynamic"}
        workflow_config = {"baseUrl": "https://api.example.com"}
        prompt = "{baseUrl}/v1/{agent1Input}"

        # Act
        result = manager.apply_early_variables(
            prompt,
            agent_inputs=agent_inputs,
            workflow_config=workflow_config
        )

        # Assert
        assert result == "https://api.example.com/v1/Dynamic"

    def test_apply_early_variables_missing_variable(self, mocker):
        """Tests that missing variables are handled gracefully with partial substitution and warning."""
        # Arrange
        mock_logger = mocker.patch('Middleware.workflows.managers.workflow_variable_manager.logger.warning')
        manager = WorkflowVariableManager()
        agent_inputs = {"agent1Input": "Present"}
        prompt = "{agent1Input}/{missingVariable}"

        # Act
        result = manager.apply_early_variables(prompt, agent_inputs=agent_inputs)

        # Assert
        assert result == "Present/{missingVariable}"  # Partial substitution - substitutes what it can
        mock_logger.assert_called_once()
        assert "Variables not available for early substitution" in mock_logger.call_args[0][0]

    def test_apply_early_variables_no_variables_in_prompt(self):
        """Tests that prompts without variables are returned unchanged."""
        # Arrange
        manager = WorkflowVariableManager()
        agent_inputs = {"agent1Input": "Value"}
        prompt = "StaticEndpointName"

        # Act
        result = manager.apply_early_variables(prompt, agent_inputs=agent_inputs)

        # Assert
        assert result == "StaticEndpointName"

    def test_apply_early_variables_empty_inputs(self):
        """Tests that empty inputs don't cause errors."""
        # Arrange
        manager = WorkflowVariableManager()
        prompt = "{agent1Input}"

        # Act
        result = manager.apply_early_variables(prompt, agent_inputs=None, workflow_config=None)

        # Assert
        assert result == "{agent1Input}"  # Returns original since no variables available

    def test_apply_early_variables_malformed_brackets(self, mocker):
        """Tests that malformed variable syntax is handled gracefully."""
        # Arrange
        mock_logger = mocker.patch('Middleware.workflows.managers.workflow_variable_manager.logger.warning')
        manager = WorkflowVariableManager()
        agent_inputs = {"agent1Input": "Value"}
        prompt = "{agent1Input} and {unclosed and {{double}}"

        # Act
        result = manager.apply_early_variables(prompt, agent_inputs=agent_inputs)

        # Assert
        # Should handle the valid variable and return original for invalid parts
        mock_logger.assert_called()
        assert "Error during early variable substitution" in mock_logger.call_args[0][0]

    def test_apply_early_variables_complex_template_pattern(self):
        """Tests a complex real-world pattern with multiple variables."""
        # Arrange
        manager = WorkflowVariableManager()
        agent_inputs = {
            "agent1Input": "General-Fast-Endpoint",
            "agent2Input": "Factual_Preset"
        }
        workflow_config = {
            "version": "v1",
            "environment": "production"
        }
        prompt = "{environment}/{version}/{agent1Input}?preset={agent2Input}"

        # Act
        result = manager.apply_early_variables(
            prompt,
            agent_inputs=agent_inputs,
            workflow_config=workflow_config
        )

        # Assert
        assert result == "production/v1/General-Fast-Endpoint?preset=Factual_Preset"

    def test_apply_early_variables_nodes_excluded_from_workflow_config(self):
        """Tests that 'nodes' key is properly excluded from workflow config."""
        # Arrange
        manager = WorkflowVariableManager()
        workflow_config = {
            "validKey": "validValue",
            "nodes": [{"type": "Standard"}]  # Should be excluded
        }
        prompt = "{validKey} and {nodes}"

        # Act
        result = manager.apply_early_variables(prompt, workflow_config=workflow_config)

        # Assert
        # validKey should work, nodes should not
        assert "{nodes}" in result  # nodes variable should remain unsubstituted
        assert "validValue" in result

    def test_apply_early_variables_priority_when_duplicate_keys(self):
        """Tests that agent_inputs take priority over workflow_config when keys conflict."""
        # Arrange
        manager = WorkflowVariableManager()
        agent_inputs = {"endpoint": "FromAgent"}
        workflow_config = {"endpoint": "FromWorkflow"}
        prompt = "{endpoint}"

        # Act
        result = manager.apply_early_variables(
            prompt,
            agent_inputs=agent_inputs,
            workflow_config=workflow_config
        )

        # Assert
        # agent_inputs should override workflow_config
        assert result == "FromAgent"

    def test_apply_early_variables_special_characters_in_values(self):
        """Tests that special characters in values don't break substitution."""
        # Arrange
        manager = WorkflowVariableManager()
        agent_inputs = {
            "agent1Input": "endpoint-with-dash_and_underscore.v1",
            "agent2Input": "preset@2.0"
        }
        prompt = "{agent1Input}:{agent2Input}"

        # Act
        result = manager.apply_early_variables(prompt, agent_inputs=agent_inputs)

        # Assert
        assert result == "endpoint-with-dash_and_underscore.v1:preset@2.0"

    def test_apply_early_variables_numeric_values(self):
        """Tests that numeric values in the config are handled correctly."""
        # Arrange
        manager = WorkflowVariableManager()
        workflow_config = {
            "port": 8080,
            "version": 2
        }
        prompt = "http://localhost:{port}/api/v{version}"

        # Act
        result = manager.apply_early_variables(prompt, workflow_config=workflow_config)

        # Assert
        assert result == "http://localhost:8080/api/v2"

    def test_apply_early_variables_none_values(self):
        """Tests that None values in inputs are handled correctly."""
        # Arrange
        manager = WorkflowVariableManager()
        agent_inputs = {
            "agent1Input": None,
            "agent2Input": "NotNone"
        }
        prompt = "{agent1Input}/{agent2Input}"

        # Act
        result = manager.apply_early_variables(prompt, agent_inputs=agent_inputs)

        # Assert
        assert result == "None/NotNone"  # None is converted to string "None"
